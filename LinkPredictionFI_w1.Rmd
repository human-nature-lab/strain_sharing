---
title: "LinkPrediction"
author: "Francesco Beghini"
date: "2023-11-22"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dev = c('png','svglite'))
```

# Link Prediction Methods
```{r message=FALSE, warning=FALSE, include=FALSE}
#Change format of covariates to merge onto edge list
Covars_ego <- covariates %>% merge(household_wealth_data) %>%
    unite('indigenous_status', mb_a0500a:mb_a0500i, na.rm = TRUE) |> 
  dplyr::rename(ego = respondent_master_id, ego_age = age_at_survey.x, ego_gender = gender.x,
          ego_household = building_id,
         ego_household_wealth = household_wealth_index_w3, ego_education = b0100, ego_indigenous = indigenous_status, 
         ego_religion = b0600, ego_length_in_village = b0800, ego_length_in_village_years = b0900,
         ego_DDS = DDS, 
         ego_latitude = building_latitude, ego_longitude = building_longitude) %>%
  mutate(ego_education = recode(ego_education, "Have not completed any type of school" = 0,
                                "1st grade" = 1, "2nd grade" = 2, "3rd grade" = 3,
                                "4th grade" = 4, "5th grade" = 5, "6th grade" = 6,
                                "Some secondary" = 7, "Secondary" = 8, "More than secondary" = 9),
         ego_indigenous = recode(ego_indigenous, "None of the above" = 0, " " = 0, "Lenca" = 1, "Ch'orti'/Maya Chorti"= 1)) %>% 
  dplyr::select(-c("village_name"))

Covars_alter <- covariates %>% merge(household_wealth_data) %>%
      unite('indigenous_status', mb_a0500a:mb_a0500i, na.rm = TRUE) |> 
  dplyr::rename(alter = respondent_master_id, alter_age = age_at_survey.x, alter_gender = gender.x,
         alter_household = building_id,
         alter_household_wealth = household_wealth_index_w3, alter_education = b0100, alter_indigenous = indigenous_status, 
         alter_religion = b0600, alter_length_in_village = b0800, alter_length_in_village_years = b0900,
         alter_latitude = building_latitude, alter_longitude = building_longitude) %>%
  mutate(alter_education = recode(alter_education, "Have not completed any type of school" = 0,
                                "1st grade" = 1, "2nd grade" = 2, "3rd grade" = 3,
                                "4th grade" = 4, "5th grade" = 5, "6th grade" = 6,
                                "Some secondary" = 7, "Secondary" = 8, "More than secondary" = 9),
         alter_indigenous = recode(alter_indigenous, "None of the above" = 0, " " = 0, "Lenca" = 1, "Ch'orti'/Maya Chorti"= 1)) %>% 
  dplyr::select(-c("village_name"))



#Merge covariate data onto edge list
SN_All_Covars_stable_ties <- merge(SN, Covars_ego, by = "ego")
SN_All_Covars_stable_ties <- merge(SN_All_Covars_stable_ties, Covars_alter, by = "alter")
SN_All_Covars_stable_ties <- SN_All_Covars_stable_ties[SN_All_Covars_stable_ties$pair_key %in% intersect(SN_All_Covars_stable_ties$pair_key, SN_w1$pair), ] 
  # left_join(Covars_ego, by = join_by(ego)) |> 
  # left_join(Covars_alter, by = join_by(alter)) 
```

```{r get_covariate_matrix_no_relationship, message=FALSE, warning=FALSE, include=FALSE}
#Get covariate matrix for people without a relationship
village_names <- unique(SN_All_Covars_stable_ties$village_code_w3)
foreach(v = village_names, .combine = rbind) %do%
{
  #Split up matrix into villages
  SN_Village_w3 <- SN_All_Covars_stable_ties %>% filter(village_code_w3 == v)
  #IDs of everyone in village
  Village_IDs_w3 <- unique(c(as.character(SN_Village_w3$ego), as.character(SN_Village_w3$alter)))
  data.frame(t(combn(Village_IDs_w3, 2, simplify = TRUE))) |> 
    dplyr::rename(ego = X1, alter = X2) |> 
    mutate(pair = vapply(stri_split_boundaries(str_c(ego, alter), type='character'), function(x) stri_c(x[stri_order(x)], collapse = ''), '')) |> 
    filter(!pair %in% SN_Village_w3$pair) |> 
    inner_join(Covars_ego, by = 'ego') |> 
    inner_join(Covars_alter, by = 'alter', suffix = c('_ego','_alter')) |> 
    mutate(
      relationship = "Un-Nominated Same Village",
      village_code_w3 = v,
      gender.mm = ego_gender == 'man' & alter_gender == 'man',
      gender.mf = ego_gender == "man" & alter_gender == "woman" | ego_gender == "woman" & alter_gender == "man",
      gender.ff = ego_gender == 'woman' & alter_gender == 'woman',
      indigenous.both = ego_indigenous == 1 & alter_indigenous == 1, 
      indigenous.one = ego_indigenous == 1 & alter_indigenous == 0 | ego_indigenous == 0 & alter_indigenous == 1,
      indigenous.none = ego_indigenous == 0 & alter_indigenous == 0,
      religion.same = ego_religion == alter_religion,
      age_difference_abs = abs(ego_age - alter_age),
      average_age = (ego_age + alter_age)/2,
      wealth_difference_abs = abs(ego_household_wealth - alter_household_wealth),
      average_wealth = (ego_household_wealth + alter_household_wealth)/2,
      education_difference_abs = abs(ego_education - alter_education),
      average_education = (ego_education + alter_education)/2,
      household_same = ego_household == alter_household
    ) |> 
    rowwise() |> 
    mutate(strain_sharing_rate = strain_rate[ego, alter],
           bray_curtis_sim = species_bray[ego, alter])
} -> All_NoRel_Covars_w3


#Get dataframe of relationships into format for regression
SN_All_Covars_for_Regression_stable_ties <- SN_All_Covars_stable_ties %>% distinct(pair_key, .keep_all = TRUE) %>%
  mutate(gender.mm = ego_gender == "man" & alter_gender == "man",
         gender.mf = ego_gender == "woman" & alter_gender == "man" | ego_gender == "man" & alter_gender == "woman",
         gender.ff = ego_gender == "woman" & alter_gender == "woman",
         indigenous.both = ego_indigenous == 1 & alter_indigenous == 1,
         indigenous.one = ego_indigenous == 1 & alter_indigenous == 0 | ego_indigenous == 0 & alter_indigenous == 1,
         indigenous.none = ego_indigenous == 0 & alter_indigenous == 0,
         religion.same = ego_religion == alter_religion,
         age_difference_abs = abs(ego_age - alter_age),
         average_age = (ego_age + alter_age)/2,
         wealth_difference_abs = abs(ego_household_wealth - alter_household_wealth),
         average_wealth = (ego_household_wealth + alter_household_wealth)/2,
         education_difference_abs = abs(ego_education - alter_education),
         average_education = (ego_education + alter_education)/2,
         household_same = ego_household == alter_household)
```

```{r message=FALSE, warning=FALSE, include=FALSE}
#Make dataframe with only non-kin in different house
SN_Non_Kin_Dif_House_Covars_for_Regression_stable_ties<- SN_All_Covars_for_Regression_stable_ties %>%
  filter(!(pair_key %in% family_house_pairs))


#select predictors
SN_All_Covars_for_Regression_stable_ties <- SN_All_Covars_for_Regression_stable_ties %>%
  mutate(related = 1) %>% 
  dplyr::select("ego","alter","gender.mm", "gender.mf", "indigenous.both", "indigenous.one", "religion.same",
         "age_difference_abs", "average_age", "wealth_difference_abs",
         "average_wealth", "education_difference_abs","average_education", "household_same",
         "related", "strain_sharing_rate", "village_code_w3", "bray_curtis_sim")

SN_Non_Kin_Dif_House_Covars_for_Regression_stable_ties <- SN_Non_Kin_Dif_House_Covars_for_Regression_stable_ties %>%
  mutate(related = 1) %>% 
  dplyr::select("ego","alter","gender.mm", "gender.mf", "indigenous.both", "indigenous.one", "religion.same",
         "age_difference_abs", "average_age", "wealth_difference_abs",
         "average_wealth", "education_difference_abs","average_education", "household_same",
         "related", "strain_sharing_rate", "village_code_w3", "bray_curtis_sim")



All_NoRel_Covars_for_Regression_stable_ties<- All_NoRel_Covars_w3 %>%
  mutate(related = 0) %>%
  dplyr::select("ego","alter","gender.mm", "gender.mf", "indigenous.both", "indigenous.one", "religion.same",
                "age_difference_abs", "average_age", "wealth_difference_abs",
                "average_wealth", "education_difference_abs","average_education", "household_same",
                "related", "strain_sharing_rate", "village_code_w3", "bray_curtis_sim")


#Combine relationships and non relationship dataframe
SN_All_Covars_for_Regression_complete_stable_ties <- SN_All_Covars_for_Regression_stable_ties[complete.cases(SN_All_Covars_for_Regression_stable_ties),]

SN_Non_Kin_Dif_House_Covars_for_Regression_complete_stable_ties <- SN_Non_Kin_Dif_House_Covars_for_Regression_stable_ties[complete.cases(SN_Non_Kin_Dif_House_Covars_for_Regression_stable_ties),]

All_for_Regression_stable_ties <- rbind(All_NoRel_Covars_for_Regression_stable_ties, SN_All_Covars_for_Regression_stable_ties)

Non_Kin_House_for_Regression_stable_ties <- rbind(All_NoRel_Covars_for_Regression_stable_ties,
                                      SN_Non_Kin_Dif_House_Covars_for_Regression_complete_stable_ties)

#May want to check if this is missing completely at random or input columns
#filter to complete cases
All_for_Regression_complete_stable_ties <- All_for_Regression_stable_ties[complete.cases(All_for_Regression_stable_ties),]

All_NoRel_Covars_for_Regression_complete_stable_ties <- All_NoRel_Covars_for_Regression_stable_ties[complete.cases(All_NoRel_Covars_for_Regression_stable_ties),]

Non_Kin_House_for_Regression_complete_stable_ties <-
  Non_Kin_House_for_Regression_stable_ties[complete.cases(Non_Kin_House_for_Regression_stable_ties),]

edge_counts <- SN_All_Covars_for_Regression_complete_stable_ties %>%
  group_by(village_code_w3) %>%
  summarize(edge_count = sum(related)) 

edge_counts <- edge_counts[match(village_names, edge_counts$village_code_w3),] %>%
  filter(!is.na(village_code_w3)) |> 
  pull(edge_count, village_code_w3)

edge_counts_nkh <- SN_Non_Kin_Dif_House_Covars_for_Regression_complete_stable_ties %>%
  group_by(village_code_w3) %>%
  summarize(edge_count = sum(related))

edge_counts_nkh <- edge_counts_nkh[match(village_names, edge_counts_nkh$village_code_w3),] %>%
  filter(!is.na(village_code_w3)) |> 
  pull(edge_count, village_code_w3)



```


```{r Downsample, message=FALSE, warning=FALSE, include=FALSE}
#Downsample

foreach(v = names(edge_counts), .combine = rbind) %do% {
  All_NoRel_Covars_for_Regression_complete_stable_ties %>%
  filter(village_code_w3 == as.integer(v)) %>% slice_sample(n = edge_counts[v])
} -> Downsamp_all

Downsamp_all <- rbind(Downsamp_all, SN_All_Covars_for_Regression_complete_stable_ties)

Downsamp_all <- Downsamp_all[complete.cases(Downsamp_all),]

#Non-kin different house

foreach(v = names(edge_counts_nkh), .combine = rbind) %do% {
  All_NoRel_Covars_for_Regression_complete_stable_ties %>%
  filter(village_code_w3 == as.integer(v)) %>% slice_sample(n = edge_counts_nkh[v])
} -> Downsamp_all_nkh

Downsamp_all_nkh <- rbind(Downsamp_all_nkh, SN_Non_Kin_Dif_House_Covars_for_Regression_complete_stable_ties)

Downsamp_all_nkh <- Downsamp_all_nkh[complete.cases(Downsamp_all_nkh),]
```



```{r oos_5cv, message=FALSE, warning=FALSE, include=FALSE}
cl <- parallel::makeCluster(5)
doParallel::registerDoParallel(cl)
foreach(i = c(1:5)) %dopar% {
  print(i)
  inds <- c(1:nrow(Downsamp_all))
  test1_inds <- sample(inds, size = floor(.33*nrow(Downsamp_all)), replace = F)
  train1_inds <- inds[!(inds %in% test1_inds)]
  test2_inds <- sample(train1_inds, size = floor(.5*length(train1_inds)), replace = F)
  train2_inds <- inds[!(inds %in% test2_inds)]
  test3_inds <- train2_inds[!(train2_inds %in% test1_inds)]
  train3_inds <- inds[!(inds %in% test3_inds)]

  train1 <- Downsamp_all[train1_inds,]
  test1 <- Downsamp_all[test1_inds,]
  train2 <- Downsamp_all[train2_inds,]
  test2 <- Downsamp_all[test2_inds,]
  train3 <- Downsamp_all[train3_inds,]
  test3 <- Downsamp_all[test3_inds,]

  logit.test.1 <- lme4::glmer(related ~ strain_sharing_rate + (0+strain_sharing_rate|village_code_w3),
                              data = train1, family = binomial)
  logit.test.2 <- lme4::glmer(related ~ strain_sharing_rate + (0+strain_sharing_rate|village_code_w3),
                              data = train2, family = binomial)
  logit.test.3 <- lme4::glmer(related ~ strain_sharing_rate + (0+strain_sharing_rate|village_code_w3),
                              data = train3, family = binomial)
  preds.1 <- predict(logit.test.1, newdata = test1, type = "response")
  preds.2 <- predict(logit.test.2, newdata = test2, type = "response")
  preds.3 <- predict(logit.test.3, newdata = test3, type = "response")
  names(preds.3) <- test3_inds
  names(preds.2) <- test2_inds
  names(preds.1) <- test1_inds
  preds.round <- c(preds.1, preds.2, preds.3)
  preds.round <- preds.round[order(as.numeric(names(preds.round)))]
  
  
  logit.test.1 <- lme4::glmer(related ~ gender.mm + gender.mf + indigenous.both +
                        indigenous.one + religion.same + age_difference_abs +
                        average_age + wealth_difference_abs + average_wealth +
                        education_difference_abs + average_education +
                        strain_sharing_rate + household_same +(1|village_code_w3),
                              data = train1, family = binomial)
  logit.test.2 <- lme4::glmer(related ~ gender.mm + gender.mf + indigenous.both +
                        indigenous.one + religion.same + age_difference_abs +
                        average_age + wealth_difference_abs + average_wealth +
                        education_difference_abs + average_education +
                        strain_sharing_rate + household_same + (1|village_code_w3),
                              data = train2, family = binomial)
  logit.test.3 <- lme4::glmer(related ~ gender.mm + gender.mf + indigenous.both +
                        indigenous.one + religion.same + age_difference_abs +
                        average_age + wealth_difference_abs + average_wealth +
                        education_difference_abs + average_education +
                        strain_sharing_rate + household_same + (1|village_code_w3),
                              data = train3, family = binomial)
  preds.1 <- predict(logit.test.1, newdata = test1, type = "response")
  preds.2 <- predict(logit.test.2, newdata = test2, type = "response")
  preds.3 <- predict(logit.test.3, newdata = test3, type = "response")
  names(preds.3) <- test3_inds
  names(preds.2) <- test2_inds
  names(preds.1) <- test1_inds
  preds.onlycovars <- c(preds.1, preds.2, preds.3)
  preds.onlycovars <- preds.onlycovars[order(as.numeric(names(preds.onlycovars)))]
  

  logit.test.1.covars <- lme4::glmer(related ~ gender.mm + gender.mf + 
                                     age_difference_abs + average_age  +
                                    strain_sharing_rate + household_same + (0+strain_sharing_rate|village_code_w3),
                              data = train1, family = binomial)
  logit.test.2.covars <- lme4::glmer(related ~ gender.mm + gender.mf +
                                       age_difference_abs + average_age +
                                       strain_sharing_rate + household_same + (0+strain_sharing_rate|village_code_w3),
                              data = train2, family = binomial)
  logit.test.3.covars <- lme4::glmer(related ~ gender.mm + gender.mf + 
                                       age_difference_abs + average_age +
                                       strain_sharing_rate + household_same + (0+strain_sharing_rate|village_code_w3),
                              data = train3, family = binomial)
  
  preds.1.covar <- predict(logit.test.1.covars, newdata = test1, type = "response")
  preds.2.covar <- predict(logit.test.2.covars, newdata = test2, type = "response")
  preds.3.covar <- predict(logit.test.3.covars, newdata = test3, type = "response")
  names(preds.3.covars) <- test3_inds
  names(preds.2.covars) <- test2_inds
  names(preds.1.covars) <- test1_inds
  preds.round.covars <- c(preds.1.covar, preds.2.covars, preds.3.covars)
  preds.round.covars <- preds.round.covars[order(as.numeric(names(preds.round.covars)))]
  
  
  logit.test.1.all <- lme4::glmer(related ~ gender.mm + gender.mf + indigenous.both +
                        indigenous.one + religion.same + age_difference_abs +
                        average_age + wealth_difference_abs + average_wealth +
                        education_difference_abs + average_education +
                        strain_sharing_rate + household_same + (0+strain_sharing_rate|village_code_w3),
                              data = train1, family = binomial)
  logit.test.2.all <- lme4::glmer(related ~ gender.mm + gender.mf + indigenous.both +
                        indigenous.one + religion.same + age_difference_abs +
                        average_age + wealth_difference_abs + average_wealth +
                        education_difference_abs + average_education +
                        strain_sharing_rate + household_same + (0+strain_sharing_rate|village_code_w3),
                              data = train2, family = binomial)
  logit.test.3.all <- lme4::glmer(related ~ gender.mm + gender.mf + indigenous.both +
                        indigenous.one + religion.same + age_difference_abs +
                        average_age + wealth_difference_abs + average_wealth +
                        education_difference_abs + average_education +
                        strain_sharing_rate + household_same + (0+strain_sharing_rate|village_code_w3),
                              data = train3, family = binomial)
  
  preds.1.all <- predict(logit.test.1.all, newdata = test1, type = "response")
  preds.2.all <- predict(logit.test.2.all, newdata = test2, type = "response")
  preds.3.all <- predict(logit.test.3.all, newdata = test3, type = "response")
  names(preds.3.all) <- test3_inds
  names(preds.2.all) <- test2_inds
  names(preds.1.all) <- test1_inds
  preds.round.all <- c(preds.1.all, preds.2.all, preds.3.all)
  preds.round.all <- preds.round.all[order(as.numeric(names(preds.round.all)))]
  
  list(preds.round, preds.onlycovars, preds.covars, preds.round.all)
} -> preds
parallel::stopCluster(cl)

#Could make this without random effect don't have to deal with this stuff
pred.all <- rowSums(sapply(preds, `[[`, 1))/5
pred.all.all <- rowSums(sapply(preds, `[[`, 2))/5

#add on predictions from strain-sharing only model
pred.all.acc <- pred.all
pred.all.acc[pred.all.acc >=.5] <- 1
pred.all.acc[pred.all.acc <.5] <- 0

Downsamp_all$predicted <- pred.all.acc

#Create ROC object weird it got worse, could do this over multiple downsamples as well
#I think my predictions will be fairly consistent
logit.base.roc <- pROC::roc(Downsamp_all$related, pred.all, ci=TRUE, plot=FALSE,
                levels=c("0","1"), direction = "<")

logit.all.roc <- pROC::roc(Downsamp_all$related, pred.all.all, ci=TRUE, plot=FALSE,
                levels=c("0","1"), direction = "<")

pROC::auc(logit.base.roc)[1]
pROC::auc(logit.all.roc)[1]


roc.list <- list("Strain-Sharing Rate (Stable ties)" = logit.base.roc,
                 "SSR + All Socio-Dem Covars (Stable ties)" = logit.all.roc)

ci.list <- lapply(roc.list, ci.se, specificities = seq(0, 1, l = 25))

dat.ci.list <- lapply(ci.list, function(ciobj) 
  data.frame(x = as.numeric(rownames(ciobj)),
             lower = ciobj[, 1],
             upper = ciobj[, 3]))
```
## All Social or Familial Relationship (on Stable ties W1-W3)
```{r plot_roc_all_famililar_social_stable_ties, echo=FALSE, message=FALSE, warning=FALSE}
roc.plot <- ggroc(roc.list) +
  theme_minimal() +
  geom_abline(slope=1, intercept = 1, linetype = "dashed", alpha=1, color = "grey") +
  coord_equal()

for(i in 1:2) {
  roc.plot <- roc.plot + geom_ribbon(
    data = dat.ci.list[[i]],
    aes(x = x, ymin = lower, ymax = upper),
    fill = i + 1,
    alpha = 0.2,
    inherit.aes = F) 
  } 

roc.plot <- roc.plot + 
theme(plot.title = element_text(size=10, hjust = .5),
      legend.position = c(0.6, 0.2),
      legend.text = element_text(size=10),
      text = element_text(size = 10)) + 
      scale_color_manual(name = "AUCs:",
                         values=c("Red", "Green", "Blue"), 
                       labels=c(paste("Strain-Sharing Rate (Stable ties): ", round(logit.base.roc$auc,2),
                                      " ± ",round(sqrt(pROC::var(logit.base.roc)),3), sep=""), 
                                paste("SSR + All Socio-Dem Covars (Stable ties): ", round(logit.all.roc$auc, 2),
                                      " ± ",round(sqrt(pROC::var(logit.all.roc)),3), sep="")
                                )
                       ) +
  ggtitle("All Social or Familial Relationships (Stable ties)")

roc.plot <- roc.plot +
  theme_pubr(legend =  c(0.6, 0.2)) +
  theme(plot.title = element_text(size = 10, hjust = .5)) +
  labs_pubr()

roc.plot <- roc.plot + theme(
  plot.title = element_text(size = 10, hjust = .5),
  legend.title = element_text(size = 8),
  legend.text = element_text(size = 8)
)

svglite('Figures/plot_roc_all_famililar_social_stable_ties.svg')
roc.plot
dev.off()
```


```{r ood_5cv_nonkin, message=FALSE, warning=FALSE, include=FALSE}
cl <- parallel::makeCluster(5)
doParallel::registerDoParallel(cl)
foreach(i = c(1:5)) %dopar% {
  inds <- c(1:nrow(Downsamp_all_nkh))
  test1_inds <- sample(inds, size = floor(.33*nrow(Downsamp_all_nkh)), replace = F)
  train1_inds <- inds[!(inds %in% test1_inds)]
  test2_inds <- sample(train1_inds, size = floor(.5*length(train1_inds)), replace = F)
  train2_inds <- inds[!(inds %in% test2_inds)]
  test3_inds <- train2_inds[!(train2_inds %in% test1_inds)]
  train3_inds <- inds[!(inds %in% test3_inds)]
  
  train1 <- Downsamp_all_nkh[train1_inds,]
  test1 <- Downsamp_all_nkh[test1_inds,]
  train2 <- Downsamp_all_nkh[train2_inds,]
  test2 <- Downsamp_all_nkh[test2_inds,]
  train3 <- Downsamp_all_nkh[train3_inds,]
  test3 <- Downsamp_all_nkh[test3_inds,]
  
  logit.test.1 <- lme4::glmer(related ~ strain_sharing_rate + (0+strain_sharing_rate|village_code_w3),
                              data = train1, family = binomial)
  logit.test.2 <- lme4::glmer(related ~ strain_sharing_rate + (0+strain_sharing_rate|village_code_w3),
                              data = train2, family = binomial)
  logit.test.3 <- lme4::glmer(related ~ strain_sharing_rate + (0+strain_sharing_rate|village_code_w3),
                              data = train3, family = binomial)
  preds.1 <- predict(logit.test.1, newdata = test1, type = "response")
  preds.2 <- predict(logit.test.2, newdata = test2, type = "response")
  preds.3 <- predict(logit.test.3, newdata = test3, type = "response")
  names(preds.3) <- test3_inds
  names(preds.2) <- test2_inds
  names(preds.1) <- test1_inds
  preds.round <- c(preds.1, preds.2, preds.3)
  preds.round <- preds.round[order(as.numeric(names(preds.round)))]
  
  logit.test.1.all <- lme4::glmer(related ~ gender.mm + gender.mf + indigenous.both +
                        indigenous.one + religion.same + age_difference_abs +
                        average_age + wealth_difference_abs + average_wealth +
                        education_difference_abs + average_education +
                        strain_sharing_rate + (0+strain_sharing_rate|village_code_w3),
                              data = train1, family = binomial)
  logit.test.2.all <- lme4::glmer(related ~ gender.mm + gender.mf + indigenous.both +
                        indigenous.one + religion.same + age_difference_abs +
                        average_age + wealth_difference_abs + average_wealth +
                        education_difference_abs + average_education +
                        strain_sharing_rate + (0+strain_sharing_rate|village_code_w3),
                              data = train2, family = binomial)
  logit.test.3.all <- lme4::glmer(related ~ gender.mm + gender.mf + indigenous.both +
                        indigenous.one + religion.same + age_difference_abs +
                        average_age + wealth_difference_abs + average_wealth +
                        education_difference_abs + average_education +
                        strain_sharing_rate + (0+strain_sharing_rate|village_code_w3),
                              data = train3, family = binomial)
  
  preds.1.all <- predict(logit.test.1.all, newdata = test1, type = "response")
  preds.2.all <- predict(logit.test.2.all, newdata = test2, type = "response")
  preds.3.all <- predict(logit.test.3.all, newdata = test3, type = "response")
  names(preds.3.all) <- test3_inds
  names(preds.2.all) <- test2_inds
  names(preds.1.all) <- test1_inds
  preds.round.all <- c(preds.1.all, preds.2.all, preds.3.all)
  preds.round.all <- preds.round.all[order(as.numeric(names(preds.round.all)))]
  
  list(preds.round, preds.round.all)
} -> preds
parallel::stopCluster(cl)

pred.all <- rowSums(sapply(preds, `[[`, 1))/5
pred.all.all <- rowSums(sapply(preds, `[[`, 2))/5

pred.all.acc <- pred.all
pred.all.acc[pred.all.acc >=.5] <- 1
pred.all.acc[pred.all.acc <.5] <- 0

Downsamp_all_nkh$predicted <- pred.all.acc

#Create ROC object weird it got worse, could do this over multiple downsamples as well
#I think my predictions will be fairly consistent
logit.base.roc <- pROC::roc(Downsamp_all_nkh$related, pred.all, ci=TRUE, plot=FALSE,
                levels=c("0","1"), direction = "<")

logit.all.roc <- pROC::roc(Downsamp_all_nkh$related, pred.all.all, ci=TRUE, plot=FALSE,
                levels=c("0","1"), direction = "<")

pROC::auc(logit.base.roc)[1]
pROC::auc(logit.all.roc)[1]

roc.list <- list("Strain-Sharing Rate (Stable ties)" = logit.base.roc,
                 "SSR + All Socio-Dem Covars (Stable ties)" = logit.all.roc)

ci.list <- lapply(roc.list, ci.se, specificities = seq(0, 1, l = 25))

dat.ci.list <- lapply(ci.list, function(ciobj) 
  data.frame(x = as.numeric(rownames(ciobj)),
             lower = ciobj[, 1],
             upper = ciobj[, 3]))
```

## Non-Kin different house Relationships (on Stable ties W1-W3) model
```{r plot_roc_non_kin_different_house, echo=FALSE, message=FALSE, warning=FALSE}
roc.plot.nkh <- ggroc(roc.list) +
  theme_minimal() +
  geom_abline(slope=1, intercept = 1, linetype = "dashed", alpha=1, color = "grey") +
  coord_equal()

for(i in 1:2) {
  roc.plot.nkh <- roc.plot.nkh + geom_ribbon(
    data = dat.ci.list[[i]],
    aes(x = x, ymin = lower, ymax = upper),
    fill = i + 1,
    alpha = 0.2,
    inherit.aes = F) 
  } 

roc.plot.nkh <- roc.plot.nkh + 
theme(plot.title = element_text(size=10, hjust = .5),
      legend.position = c(0.6, 0.2),
      legend.text = element_text(size=10),
      text = element_text(size = 10)) + 
      scale_color_manual(name = "AUCs:",
                         values=c("Red", "Green", "Blue"), 
                       labels=c(paste("Strain-Sharing Rate (Stable ties): ", round(logit.base.roc$auc,2),
                                      " ± ",round(sqrt(pROC::var(logit.base.roc)),3), sep=""), 
                                paste("SSR + All Socio-Dem Covars (Stable ties): ", round(logit.all.roc$auc, 2),
                                      " ± ",round(sqrt(pROC::var(logit.all.roc)),3), sep="")
                                )
                       ) +
  ggtitle("Non-Kin Different House Relationships (Stable ties)")

roc.plot.nkh <- roc.plot.nkh +
  theme_pubr(legend =  c(0.6, 0.2)) +
  theme(plot.title = element_text(size = 10, hjust = .5)) +
  labs_pubr()

roc.plot.nkh <- roc.plot.nkh + theme(
  plot.title = element_text(size = 10, hjust = .5),
  legend.title = element_text(size = 8),
  legend.text = element_text(size = 8)
)

svglite('Figures/plot_roc_non_kin_different_house.svg')
roc.plot.nkh
dev.off()

rocs_1 <-ggarrange(roc.plot, roc.plot.nkh, nrow = 2, labels = c("A", "B"), widths = 1)
svglite('Figures/plot_allroc_stable_ties.svg')
rocs_1
dev.off()
```

```{r}
#Ah that's it
#See which villages have the best accuracy
Downsamp_all %>% group_by(village_code_w3) %>% summarize(acc = mean(predicted == related),
                                                         perc_pred = mean(predicted),
                                                         perc_real = mean(related),
                                                         tp = mean(predicted == 1 & related ==1))

Downsamp_all %>% filter(related == 1)%>% group_by(village_code_w3) %>%
  summarize(acc = mean(predicted == related))

Downsamp_all_nkh %>% group_by(village_code_w3) %>% summarize(acc = mean(predicted == related),
                                                         perc_pred = mean(predicted),
                                                         perc_real = mean(related),
                                                         tp = mean(predicted == 1 & related ==1))
```
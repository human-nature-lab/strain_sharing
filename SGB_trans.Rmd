---
title: "Untitled"
author: "Jackson Pullman"
date: "2023-01-19"
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
getwd()
test <- readRDS("strain_trans_full.rds")

new_strain_rate <- readRDS("../../../Downloads/shared_3Dmatrix_dist.RDS")
new_strain_share <- readRDS("../../../Downloads/shared_3Dmatrix_shared.RDS")

str(new_strain_rate)

names(master_key)
master_key$mb_m01 <- paste0(substr(master_key$mb_m05,1,9),"00")

for(i in 1:length(new_strain_rate)){
  rownames(new_strain_rate[[i]]) <- master_key$respondent_master_id[match(rownames(new_strain_rate[[i]]),
                                                                        master_key$mb_m01)]
  colnames(new_strain_rate[[i]]) <- master_key$respondent_master_id[match(colnames(new_strain_rate[[i]]),
                                                                        master_key$mb_m01)]
}

for(i in 1:length(new_strain_share)){
  rownames(new_strain_share[[i]]) <- master_key$respondent_master_id[match(rownames(new_strain_share[[i]]),
                                                                        master_key$mb_m01)]
  colnames(new_strain_share[[i]]) <- master_key$respondent_master_id[match(colnames(new_strain_share[[i]]),
                                                                        master_key$mb_m01)]
}

new_strain_rate_binary <- new_strain_rate
#Need to get adjacency matrix of spouses
for(i in 1:length(new_strain_rate_binary)){
  new_strain_rate_binary[[i]][new_strain_rate_binary[[i]] >0] <-1
}

new_possible_share_spouse <- new_strain_rate_binary

SN_spouse <- SN %>%
  filter(relationship == "Mother") %>%
  graph_from_data_frame(directed = FALSE) %>%
  simplify() %>%
  as_adjacency_matrix(sparse = FALSE)

new_strain_share_spouse <- new_strain_share


possible_ct <- c()
for(i in 1:length(new_possible_share_spouse)){
  possible <- new_possible_share_spouse[[i]]
  possible <- possible[rownames(possible) %in% rownames(SN_spouse),
                       colnames(possible) %in% colnames(SN_spouse)]
  rels <- SN_spouse[match(rownames(possible), rownames(SN_spouse)),
                    match(colnames(possible), colnames(SN_spouse))]
  
  possible <- possible * rels
  possible[lower.tri(possible, diag = TRUE)] <- NA
  possible_ct <- c(possible_ct, sum(possible, na.rm = TRUE))
}

actual_ct <- c()
for(i in 1:length(new_strain_share_spouse)){
  actual <- new_strain_share_spouse[[i]]
  actual <- actual[rownames(actual) %in% rownames(SN_spouse),
                       colnames(actual) %in% colnames(SN_spouse)]
  rels <- SN_spouse[match(rownames(actual), rownames(SN_spouse)),
                    match(colnames(actual), colnames(SN_spouse))]
  
  actual <- actual * rels
  actual[lower.tri(actual, diag = TRUE)] <- NA
  actual_ct <- c(actual_ct, sum(actual, na.rm = TRUE))
}


sgb_trans_spouse <- actual_ct/possible_ct


names(sgb_trans_spouse) <- names(new_strain_share_spouse)

sgb_trans_spouse <- sgb_trans_spouse[possible_ct >=10]


new_names <- names(sgb_trans_spouse)
new_names <- substr(new_names, 4, 50)

strain_names <- colnames(species_data)


for(i in 1:length(new_names)){
  new_names[i] <- strain_names[grepl(paste0("\\(",new_names[i], "\\)"), strain_names)]
}
names(sgb_trans_spouse) <- new_names


for(i in 1:nrow(centrality_sim_df)){
  name <- centrality_sim_df$respondent_master_id[i]
  ego_species <- species_data[rownames(species_data) == name,]
  ego_species <- names(ego_species)[ego_species >0]
  centrality_sim_df$average_sgb_trans[i] <- mean(sgb_trans_spouse[names(sgb_trans_spouse) %in% ego_species])
}

#This is potentially promising
cor.test(centrality_sim_df$degree_c,
         centrality_sim_df$average_sgb_trans)

plot(centrality_sim_df$degree_c,
         centrality_sim_df$average_sgb_trans)

centrality_sim_df_sgb <- merge(centrality_sim_df, covariates)

lm.1 <- lmerTest::lmer(average_sgb_trans ~ degree_c + age_at_survey +
                         household_wealth_index_w3 +
                         gender+ (1|village),
             data = centrality_sim_df_sgb)
summary(lm.1)

#None hold up!

```


```{r}
new_strain_rate_binary$t__SGB1005[1:5,1:5]


rownames(new_strain_rate[[1]]) <- master_key$respondent_master_id[match(rownames(new_strain_rate[[1]]),
                                                                        master_key$mb_m01)]
#Only have species for 
length(new_strain_rate)
new_strain_rate$t__SGB1005[1:5,1:5]
new_strain_share$t__SGB1005[1:5,1:5]

test <- simplify2array(new_strain_rate)
str(test)

dim(test)

library(abind)
testArray <- abind(new_strain_rate, along = 3)

test[1:5,1:5,1:5]

hist(test[test >0])

test1 <- readRDS("strain_12-1_use (1).rds")
test2 <- readRDS("strain_12-2_use (1).rds")
test3 <- readRDS("strain_12-3_use (1).rds")

strain_names <- read.csv("mb_samp_st (1).csv")

species_for_trans <- species_data[, species_names$x %in% strain_names$V1]

species_for_trans <- species_for_trans[,match(strain_names$V1,colnames(species_for_trans))]

colnames(species_for_trans) == strain_names$V1


species_for_trans1 <- species_for_trans[,1:215]
species_for_trans2 <- species_for_trans[,216:430]
species_for_trans2 <- species_for_trans[,431:645]

#Calculate SGB transmissibility
test1[1:5,1:5,1]

#Calculate potential strain-sharing events for each species
potential_ss <- c()
for(i in 1:645){
  potential_sum <- 0
  #Get potential shared strains in each village
  for(j in 1:length(village_names)){
    shared_species_village <- species_for_trans[rownames(species_for_trans) %in%
                                                get(paste0("village_ids_",j)), ]
    shared_species_village <- shared_species_village[,i] %*% t(shared_species_village[,i])
    diag(shared_species_village) <- 0
    potential_sum <- potential_sum + sum(shared_species_village>0)
  }
  potential_ss <- c(potential_ss, potential_sum)
  
}

#Very high minimum beacuse all species relatively prevalent, may want to not do this, all numbers will be small
min(potential_ss)


#Potential building transmission
potential_ss <- c()
#Should probably actually do it by the number of people who have reported relationships
#First get list of people with these species
#Then get the number of people who have the same species and a reported relationship
#Use that as potential strain-sharing
#I can make a big adjacency matrix for the whole social network
#Just cross that with the 

#Transmission based on spouses
big_sn_adj <- as_adjacency_matrix(simplify(graph_from_data_frame(SN %>%
                                                                   filter(relationship == "Partner") %>%
                                                                   distinct(pair_key, .keep_all = TRUE),
                                                                 directed = FALSE)))


species_for_trans <- species_for_trans[rownames(species_for_trans) %in% rownames(big_sn_adj),]
species_for_trans <- species_for_trans[match(rownames(big_sn_adj), rownames(species_for_trans)),]

rownames(species_for_trans) == rownames(big_sn_adj)

potential_ss_rels <- c()
for(i in 1:645){
  new_test <- species_for_trans[,i] %*% t(species_for_trans[,i])
  new_test[new_test>0] <- 1
  potential_ss_rel <- new_test* big_sn_adj
  potential_ss_rels <- c(potential_ss_rels, sum(potential_ss_rel)/2)
  
}

#Calculate actual strain-sharing events

#Don't count the strains as shared if there is no relationship between the people
#Get test dataframes is same order as my adjacency matrix
strain_ego_name <- read.csv("mb_list (1).csv")


strain_ego_name <- master_key$respondent_master_id[match(strain_ego_name$x, master_key$mb_m05)]

test1_ordered <- test1[match(rownames(big_sn_adj), strain_ego_name),
               match(rownames(big_sn_adj), strain_ego_name),]

test2_ordered <- test2[match(rownames(big_sn_adj), strain_ego_name),
               match(rownames(big_sn_adj), strain_ego_name),]

test3_ordered <- test3[match(rownames(big_sn_adj), strain_ego_name),
               match(rownames(big_sn_adj), strain_ego_name),]



strain_names$V1[grepl("SGB15332", strain_names$V1)]
which(strain_names$V1 == "Faecalibacterium_prausnitzii (SGB15332_group)")



actual_ss <- c()
for(i in 1:215){
  actual_ss <- c(actual_ss, sum(test1_ordered[,,i] * big_sn_adj))
}
for(i in 1:215){
  actual_ss <- c(actual_ss, sum(test2_ordered[,,i] * big_sn_adj))
}
for(i in 1:215){
  actual_ss <- c(actual_ss, sum(test3_ordered[,,i] * big_sn_adj))
}

sgb_trans <- actual_ss/potential_ss_rels

sgb_trans <- sgb_trans[potential_ss_rels >=10]

hist(sgb_trans, breaks = 100)
#That's impossible
max(sgb_trans)

#Name Species
names(sgb_trans) <- strain_names$V1[potential_ss_rels >=10]

#This is going to be fucked for big villages, maybe just define it in house
hist(sgb_trans, breaks = 100)


for(i in 1:nrow(centrality_sim_df)){
  name <- centrality_sim_df$respondent_master_id[i]
  ego_species <- species_for_trans[rownames(species_for_trans) == name,]
  ego_species <- names(ego_species)[ego_species >0]
  centrality_sim_df$average_sgb_trans[i] <- mean(sgb_trans[names(sgb_trans) %in% ego_species])
}

#This is potentially promising
cor.test(centrality_sim_df$degree_c,
         centrality_sim_df$average_sgb_trans)

plot(centrality_sim_df$degree_c,
         centrality_sim_df$average_sgb_trans)

centrality_sim_df_covars_sgb <- merge(centrality_sim_df, covariates)

lm.1 <- lmerTest::lmer(average_sgb_trans ~ degree_c + age_at_survey +
                         household_wealth_index_w3 +
                         gender+ (1|village),
             data = centrality_sim_df_covars_sgb)
summary(lm.1)




```

```{r}
#Can't use that yet
fran_trans <- read.table("sharing_rata_new2-5.tsv", header = FALSE)

head(fran_trans)
```


